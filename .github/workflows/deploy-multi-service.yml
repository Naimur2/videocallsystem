name: Deploy Multi-Service Application

on:
  workflow_run:
    workflows: ["Build and Push Multi-Service Images"]
    types:
      - completed
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  packages: read

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}/videocallsystem

jobs:
  deploy:
    runs-on: self-hosted
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Login to GitHub Container Registry
      run: |
        echo ${{ secrets.GITHUB_TOKEN }} | sudo docker login ghcr.io -u ${{ github.actor }} --password-stdin
    
    - name: Create environment file
      run: |
        cat > .env << 'EOF'
        ${{ secrets.ENV_VARS }}
        GITHUB_REPOSITORY=${{ github.repository }}
        EOF

    - name: Pull all service images
      run: |
        echo "ðŸ”„ Pulling images sequentially to prevent resource exhaustion..."
        
        # Pull base images first (sequential to avoid overwhelming the system)
        echo "ðŸ“¦ Pulling base images..."
        sudo docker pull redis:7-alpine
        sudo docker pull postgres:15-alpine
        sudo docker pull caddy:2.7-alpine
        
        echo "â³ Brief pause to prevent resource spikes..."
        sleep 5
        
        # Pull our custom service images from GHCR (sequential)
        echo "ðŸ—ï¸ Pulling custom service images..."
        sudo docker pull ghcr.io/naimur2/videocallsystem-frontend:latest
        sudo docker pull ghcr.io/naimur2/videocallsystem-backend:latest
        sudo docker pull ghcr.io/naimur2/videocallsystem-eturnal:latest
        
        echo "âœ… All images pulled successfully"
        sudo docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | grep -E "(ghcr.io/naimur2/videocallsystem|redis|postgres|caddy)" || true
    
    - name: Deploy with multi-service compose
      run: |
        echo "ðŸ›‘ Stopping existing services..."
        sudo docker compose -f docker-compose.yml down --remove-orphans || true
        
        echo "â³ Waiting for cleanup to complete..."
        sleep 10
        
        echo "ðŸ” Validating compose configuration..."
        sudo docker compose -f docker-compose.yml config --quiet
        
        echo "ðŸ§¹ Gentle cleanup to prevent resource exhaustion..."
        sudo docker container prune -f || true
        sleep 5
        sudo docker image prune -f || true
        
        echo "ï¿½ AWS EC2 t2.large resource check:"
        echo "Memory:"
        free -h || true
        echo "CPU:"
        nproc || true
        echo "Disk:"
        df -h / || true
        
        echo "ï¿½ðŸ“‹ Available images:"
        sudo docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | head -10
        
        echo "ðŸš€ Starting services one by one to prevent resource spikes..."
        
        # Start database services first
        echo "ðŸ“Š Starting database services..."
        sudo docker compose -f docker-compose.yml up -d postgres redis
        echo "â³ Waiting for database services to be ready..."
        timeout 60 sudo docker compose -f docker-compose.yml exec postgres pg_isready -U mediasoup -d mediasoup || echo "PostgreSQL timeout"
        timeout 30 sudo docker compose -f docker-compose.yml exec redis redis-cli ping || echo "Redis timeout"
        sleep 10
        
        # Start application services with individual checks
        echo "ðŸŽ¯ Starting application services..."
        sudo docker compose -f docker-compose.yml up -d backend
        echo "â³ Waiting for backend to start..."
        sleep 20
        sudo docker compose -f docker-compose.yml logs --tail=10 backend || true
        
        sudo docker compose -f docker-compose.yml up -d eturnal  
        echo "â³ Waiting for eTURN to start (with detailed error logging)..."
        sleep 5
        
        # Monitor eTURN for crashes with detailed logging
        echo "ðŸ” Checking if eTURN is running without crashing..."
        for i in {1..6}; do
          # Check if eTURN is running
          if sudo docker compose -f docker-compose.yml ps eturnal | grep -q "running"; then
            echo "âœ… eTURN is stable and running after ${i}0 seconds"
            break
          elif sudo docker compose -f docker-compose.yml ps eturnal | grep -q "exited"; then
            echo "âŒ eTURN crashed! Detailed error analysis:"
            echo "ðŸ” Container exit code:"
            sudo docker compose -f docker-compose.yml ps eturnal
            echo "ðŸ“‹ Full eTURN logs:"
            sudo docker compose -f docker-compose.yml logs eturnal
            echo "ðŸ’¾ System resources:"
            free -h
            df -h /
            echo "ðŸ”¥ Stopping failed eTURN container..."
            sudo docker compose -f docker-compose.yml down eturnal
            exit 1
          else
            echo "â³ eTURN still starting... (attempt $i/6)"
            echo "ðŸ“‹ Current eTURN logs:"
            sudo docker compose -f docker-compose.yml logs --tail=5 eturnal || true
            sleep 15
          fi
        done
        
        echo "ðŸ” eTURN container status:"
        sudo docker compose -f docker-compose.yml ps eturnal || true
        echo "ðŸ“‹ eTURN startup logs:"
        sudo docker compose -f docker-compose.yml logs --tail=20 eturnal || true
        echo "ðŸ”— eTURN ports:"
        sudo docker port $(sudo docker compose -f docker-compose.yml ps -q eturnal) || true
        echo "ðŸ’¾ System memory after eTURN start:"
        free -h || true
        
        # Start frontend and proxy
        echo "ðŸŒ Starting frontend and proxy..."
        sudo docker compose -f docker-compose.yml up -d frontend
        sleep 15
        sudo docker compose -f docker-compose.yml logs --tail=10 frontend || true
        
        sudo docker compose -f docker-compose.yml up -d caddy
        sleep 10
        
        echo "ðŸ“Š Final service status:"
        sudo docker compose -f docker-compose.yml ps
        
        echo "âœ… All services deployed!"
    
    - name: Verify deployment
      run: |
        echo "â³ Waiting for services to fully initialize..."
        sleep 30
        
        echo "ðŸ“Š Service Status:"
        sudo docker compose -f docker-compose.yml ps || true
        
        echo ""
        echo "ðŸ’¾ System Resources:"
        free -h || true
        df -h / || true
        
        echo ""
        echo "ðŸ” Health Checks (with timeouts):"
        timeout 30 sudo docker compose -f docker-compose.yml exec -T frontend curl -f http://localhost:3000/api/health || echo "Frontend not ready yet"
        timeout 30 sudo docker compose -f docker-compose.yml exec -T backend curl -f http://localhost:8080/api/health || echo "Backend not ready yet"
        
        echo ""
        echo "ðŸ“‹ Recent Logs (limited to prevent overflow):"
        sudo docker compose -f docker-compose.yml logs --tail=3 frontend backend || true
        
        echo ""
        echo "ðŸŽ¯ Deployment Summary:"
        echo "- Frontend: ghcr.io/naimur2/videocallsystem-frontend:latest"
        echo "- Backend: ghcr.io/naimur2/videocallsystem-backend:latest" 
        echo "- eTURN: ghcr.io/naimur2/videocallsystem-eturnal:latest"
        echo "- Database: postgres:15-alpine"
        echo "- Cache: redis:7-alpine"
        echo "- Proxy: caddy:2.7-alpine"

    - name: Legacy app deployment (optional)
      if: github.event.inputs.deploy_legacy == 'true'
      run: |
        echo "ðŸ”„ Deploying legacy app as well..."
        sudo docker compose --profile legacy up -d legacy-app
        echo "âœ… Legacy app deployed"